<!--
@license
Copyright (c) 2015
-->
<script>
  'use strict';
  /**
  Behaviors with a set of filters to use with Polymer 1.0 <dom-repeat>.

  ## Use

  You can use this behaviors in your custom elements in combination with a dom-repeat element:

  ```javascript
    Polymer({
      is: 'my-list',
      behaviors: [
        PinHoleBehavior
      ],
      ...
  ```

  Just add the filters and sorts to the dom-repeat element:
  ```html
  <template is="dom-repeat" items="{{ myItems }}" filter="{{ applyFilters(filterConfig) }}" sort="{{ applySorts(sortConfig) }}">
    <li><span>{{ item }}</span></li>
  </template>
  ```

  ### Properties

  Use the properties added with the behavior to customize your lists:

  ```html
  <input type="text" value={{ similarTo::input }} />
  ```

  ## Test
  You can watch the tests [here](/components/pin-hole/test/)

  @hero hero.svg
  @demo demo/index.html
  @polymerBehavior PinHoleBehavior
   */
  var PinHoleBehavior = {

    properties: {
      similarTo: {
        type: Object,
        value: {
          text: '',
          target: '',
        }
      },
      limitTo: {
        type: String,
        value: ''
      },
      filterConfig: {
        type: Object,

      },
    },

    observers: [
      'bindFilterConfig(similarTo.text, similarTo.target, limitTo)',
    ],

    // Element Behavior

    /**
     * Default filter names.
     * Override observers if you want to use another property names
     */
    bindFilterConfig: function() {
      //console.log(this.filterConfig)
      this.filterConfig = {
        'similarTo': this.similarTo,
        'limitTo': this.limitTo,
        'limitFrom': this.limitFrom
      }
    },

    tryoutThis: {
      m:function(){return 'Title 1'}
      },
    tryout: function(item){
      var x = this.$.repeatedItem
      console.log('entrando...', x)
      if (this.similarTo.text && this.similarTo.text !== '') {
        if (this.similarTo.target && this.similarTo.target !== '') {
          var compare = ~item[this.similarTo.target].toLowerCase().indexOf(this.similsimilarTo.text);
          return (compare !== 0);
        }
        for (var key in item) {
          var compare = ~item[key].toLowerCase().indexOf(this.similarTo.text);
          return (compare !== 0);
        }

      }

      return true;

    },

    prework: function(filterConfig) {
      var that = this;
      this.filters.counter = 0;
      return function(item) {
        var indexOfItem = this.items.indexOf(item);
        console.log('filterconfig', filterConfig)
        console.log('filtro', that.filters.similarTo(item, filterConfig))
        return that.filters._limitTo(indexOfItem, filterConfig.limitTo) &&
                that.filters.similarTo(item, filterConfig);

      };
    },
    // TODO
    /**
     * Apply all filters
     * @param  {Object} filterConfig
     * @param  {Array} items
     * @return {function}
     * @example
     * applyFilters(filterConfig,myCourses)
     */
    applyFilters: function(filterConfig, items) {
      var itemFilters = function(item) {
        return this.applyFilter('similarTo', item, filterConfig.similarTo);
        //return this.similarTo(item, filterConfig.similarTo)
      };

      return this.applyFilter('limitTo', items, filterConfig.limitTo, itemFilters);
    },

    /**
     * Applys a selected filter with its params
     * @return {Object} An array element or a function
     * @example
     * applyFilter('limitTo', myCourses, limitTo)
     */
    applyFilter: function(){
      return this.filters[arguments[0]].apply(this, Array.prototype.slice.call(arguments, 1));
    },


    /**
     * A set of filters
     * @type {Object}
     */
    filters: {

      ///////////////////
      // Items filters //
      ///////////////////

      limitTo: function(data, limit) {
        this.filters.counter = 0;

        return this.filters._limitTo.bind(this, data, limit);
      },

      _limitTo: function(indexOfItem, limit) {
console.log(arguments)

        if (indexOfItem && limit && indexOfItem >= limit) {
          return false;
        }

        return true;
      },

      //////////////////
      // Item Filters //
      //////////////////

      similarTo: function(item, filterConfig) {
        console.log('similarTo entrando...', filterConfig)
        if (filterConfig.similarTo.text && filterConfig.similarTo.text !== '') {
          if (filterConfig.similarTo.target && filterConfig.similarTo.target !== '') {
            var compare = ~item[filterConfig.similarTo.target].toLowerCase().indexOf(filterConfig.similarTo.text);
            return (compare !== 0);
          }
          for (var key in item) {
            var compare = ~item[key].toLowerCase().indexOf(filterConfig.similarTo.text);
            return (compare !== 0);
          }

        }

        return true;

      },
    },

    /**
     * A set of sorts
     * @type {Object}
     */
    sorts: {

    }


  };

    // TODO
    // -Research the chance to create a entire component
    // -Make filters & sorts behaviors which complement PinHoleBehaviors

</script>
